<html>
  <head>
    <style>
      html, body { 
        background-color:#ff9ae7;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

    <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; 

    import {VRButton} from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js'; 

    var scene, camera, renderer, controls, controller, raycaster;

    var red_light, orange_light, yellow_light, green_light, blue_light, purple_light;
    var red_mixer, orange_mixer, yellow_mixer, green_mixer, blue_mixer, purple_mixer;

    var clock, sky, ground, isSelecting;

    var oldX, oldY = 0;

    var xdir, ydir, zdir;

      window.onload = function() {
        
        window.THREE = THREE;

        //
        // THREE.js code goes here!
        //

        // Create the scene
        scene = new THREE.Scene();

        // Set up the camera
        var fov = 75;
        var ratio = window.innerWidth / window.innerHeight;
        var zNear = 1;
        var zFar = 1000;

        camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
        camera.position.set(0, 0, 1);

        // Create the renderer and add the canvas
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.xr.enabled = true; 
        renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );

        document.body.appendChild(renderer.domElement);

        document.body.appendChild(VRButton.createButton(renderer));

        // Setup lights
        var ambientLight = new THREE.AmbientLight();
        scene.add(ambientLight);

        var light = new THREE.DirectionalLight(0xffffff, 3.0);
        light.position.set(10, 100, 10);
        scene.add(light);

        var position_track, clip;
        

        // // Red light
        // var red_light = new THREE.SpotLight(0xFF9AB2, 10.0, 0, Math.PI/2);
        // red_light.position.set(-100, 100, -100);
        // scene.add(red_light);

        // position_track = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2, 4 ], [ -100, 100, -100, -110, 100, -110, -110, 100, -100, -100, 100, -100 ] );
        // clip = new THREE.AnimationClip( 'Action', 4, [position_track] );

        // red_mixer = new THREE.AnimationMixer( red_light );

        // var clipAction = red_mixer.clipAction( clip );
				// clipAction.play();

        // // Orange light
        // var orange_light = new THREE.SpotLight(0xFFC79A, 10.0, 0, Math.PI/2);
        // orange_light.position.set(-60, 100, -60);
        // scene.add(orange_light);

        // position_track = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2, 4 ], [ -60, 100, -60, -85, 100, -85, -85, 100, -60, -60, 100, -60 ] );
        // clip = new THREE.AnimationClip( 'Action', 4, [position_track] );

        // orange_mixer = new THREE.AnimationMixer( orange_light );

        // var clipAction = orange_mixer.clipAction( clip );
				// clipAction.play();


        // // Yellow light
        // var yellow_light = new THREE.SpotLight(0xF8FF9A, 10.0, 0, Math.PI/2);
        // yellow_light.position.set(-20, 100, -20);
        // scene.add(yellow_light);

        // position_track = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2, 4 ], [ -20, 100, -20, -30, 100, -30, -30, 100, -20, -20, 100, -20 ] );
        // clip = new THREE.AnimationClip( 'Action', 4, [position_track] );

        // yellow_mixer = new THREE.AnimationMixer( yellow_light );

        // var clipAction = yellow_mixer.clipAction( clip );
				// clipAction.play();


        // // Green light
        // var green_light = new THREE.SpotLight(0x9AFFA4, 10.0, 0, Math.PI/2);
        // green_light.position.set(20, 100, 20);
        // scene.add(green_light);

        // position_track = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2, 4 ], [ 20, 100, 20, 10, 100, 10, 10, 100, 20, 20, 100, 20 ] );
        // clip = new THREE.AnimationClip( 'Action', 4, [position_track] );

        // green_mixer = new THREE.AnimationMixer( green_light );

        // var clipAction = green_mixer.clipAction( clip );
				// clipAction.play();


        // // Blue light
        // var blue_light = new THREE.SpotLight(0x9ADAFF, 10.0, 0, Math.PI/2);
        // blue_light.position.set(60, 100, 60);
        // scene.add(blue_light);

        // position_track = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2, 4 ], [ 60, 100, 60, 50, 100, 50, 50, 100, 60, 60, 100, 60 ] );
        // clip = new THREE.AnimationClip( 'Action', 4, [position_track] );

        // blue_mixer = new THREE.AnimationMixer( blue_light );

        // var clipAction = blue_mixer.clipAction( clip );
				// clipAction.play();



        // // Purple light
        // var purple_light = new THREE.SpotLight(0xF39AFF, 10.0, 0, Math.PI/2);
        // purple_light.position.set(100, 100, 100);
        // scene.add(purple_light);

        // position_track = new THREE.VectorKeyframeTrack( '.position', [ 0, 1, 2, 4 ], [ 100, 100, 100, 90, 100, 90, 90, 100, 100, 100, 100, 100 ] );
        // clip = new THREE.AnimationClip( 'Action', 4, [position_track] );

        // purple_mixer = new THREE.AnimationMixer( purple_light );

        // var clipAction = purple_mixer.clipAction( clip );
				// clipAction.play();



        // Background

        var geometry = new THREE.SphereGeometry( 500, 60, 40 );
        
        var texture = new THREE.TextureLoader().load( 'sky.jpg' );
        var material = new THREE.MeshBasicMaterial( { map: texture,
                                                    side: THREE.BackSide } );
        sky = new THREE.Mesh( geometry, material );
        scene.add( sky );


        // // Configure cube
        // var geometry = new THREE.BoxGeometry(20, 20, 20);
        // var material = new THREE.MeshStandardMaterial({color:0xffffff, wireframe:false});

        // var cube = new THREE.Mesh(geometry, material);
        // // scene.add(cube);
        
        // Ground
        geometry = new THREE.PlaneGeometry( 10000, 10000 );
        material = new THREE.MeshStandardMaterial( {
          color: new THREE.Color(0.5, 0.5, 1.0), roughness: 0, metalness: 0.25
        });

        geometry.rotateX( 3 * Math.PI / 2 );

        ground = new THREE.Mesh( geometry, material );

        ground.translateY(-10);

        scene.add( ground );


        // Bubbles

        var radius, x, y, z;

        for (var i = 0; i < 4000; i++) {
          radius = Math.random() * 5; 
          
          x = (Math.random() * 1000) - 500;
          y = (Math.random() * 30) - 5;
          z = (Math.random() * 1000) - 500;

          geometry = new THREE.SphereGeometry( radius, 32, 16 );
          material = new THREE.MeshPhysicalMaterial( {
            color: new THREE.Color(0.9, 0.9, 1.0), 
            transmission: 1.05 , 
            thickness: -0.5 , 
            roughness: 0 , 
            iridescence: 1 , 
            iridescenceIOR: 1 ,
            iridescenceThicknessRange: [0, 1200] ,
            clearcoat: 1 ,
            clearcoatRoughness: 0 , 
            envMapIntensity: 1.5, 
            transparent: true, 
            opacity: 0.5
          });

          var sphere = new THREE.Mesh(geometry, material);  
          
          sphere.position.set(x, y, z);

          scene.add(sphere);
        };
    
        // Setup interaction
        controls = new OrbitControls(camera, renderer.domElement);

        raycaster = new THREE.Raycaster();

        clock = new THREE.Clock();

        window.addEventListener( 'resize', onWindowResize );

        renderer.domElement.onmousedown = function( e ){
          
            var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

            var vp_coords = new THREE.Vector2( 
                        ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                        -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

            var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

            raycaster.setFromCamera(vp_coords_near, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if ( intersects.length > 0 && intersects[0].object != ground && intersects[0].object != sky) {
              intersects[0].object.visible = false;
            };

            // update cube position
            // cube.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);

          };


          renderer.domElement.onmousemove = function( e ){
          
            var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

            var vp_coords = new THREE.Vector2( 
                        ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                        -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

            var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

            raycaster.setFromCamera(vp_coords_near, camera);

            var intersects = raycaster.intersectObjects(scene.children);

            if ( intersects.length > 0 && intersects[0].object != ground && intersects[0].object != sky) {
              if (Math.abs(camera.position.x) > Math.abs(camera.position.y) && Math.abs(camera.position.x) > Math.abs(camera.position.z)) {
                if (camera.position.x > 0) {
                  if (oldX - e.clientX < 0) {
                    intersects[0].object.position.z -= 0.30;
                  } else {
                    intersects[0].object.position.z += 0.30;
                  };

                  if (oldY - e.clientY > 0) {
                    intersects[0].object.position.y += 0.30;
                  } else {
                    intersects[0].object.position.y -= 0.30;
                  };
                } else {
                  if (oldX - e.clientX < 0) {
                    intersects[0].object.position.z += 0.30;
                  } else {
                    intersects[0].object.position.z -= 0.30;
                  };

                  if (oldY - e.clientY > 0) {
                    intersects[0].object.position.y += 0.30;
                  } else {
                    intersects[0].object.position.y -= 0.30;
                  };
                };    
              };

              if (Math.abs(camera.position.z) > Math.abs(camera.position.x) && Math.abs(camera.position.z) > Math.abs(camera.position.y)) {
                if (camera.position.z > 0) {
                  if (oldX - e.clientX < 0) {
                    intersects[0].object.position.x += 0.30;
                  } else {
                    intersects[0].object.position.x -= 0.30;
                  };

                  if (oldY - e.clientY > 0) {
                    intersects[0].object.position.y += 0.30;
                  } else {
                    intersects[0].object.position.y -= 0.30;
                  };
                } else {
                  if (oldX - e.clientX < 0) {
                    intersects[0].object.position.x -= 0.30;
                  } else {
                    intersects[0].object.position.x += 0.30;
                  };

                  if (oldY - e.clientY > 0) {
                    intersects[0].object.position.y += 0.30;
                  } else {
                    intersects[0].object.position.y -= 0.30;
                  };
                };                
              };
            };

            // update cube position
            // cube.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);

            oldX = e.clientX;
            oldY = e.clientY;
          };

        xdir = [];
        ydir = [];
        zdir = [];

        for (var i = 0; i < scene.children.length; i++){
          xdir.push(1);
          ydir.push(1);
          zdir.push(1);
        };

        var controller = renderer.xr.getController( 0 );
        controller.addEventListener( 'selectstart', function () {
					controller.userData.isSelecting = true;
        } );
				controller.addEventListener( 'selectend', function () {
					controller.userData.isSelecting = false;
        } );
        controller.addEventListener( 'connected', function ( event ) {

					const targetRayMode = event.data.targetRayMode;

					if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

						controller.add( buildController( event.data ) );

					}

				} );
				controller.addEventListener( 'disconnected', function () {

					controller.remove( controller.children[ 0 ] );

				} );
        scene.add(controller);


        var controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', function () {
					controller2.userData.isSelecting = true;
        } );
				controller2.addEventListener( 'selectend', function () {
					controller2.userData.isSelecting = false;
        } );
        controller2.addEventListener( 'connected', function ( event ) {

					const targetRayMode = event.data.targetRayMode;

					if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

						controller2.add( buildController( event.data ) );

					}

				} );
				controller2.addEventListener( 'disconnected', function () {

					controller2.remove( controller2.children[ 0 ] );

				} );
        scene.add(controller2);



        var controllerModelFactory = new XRControllerModelFactory();

				var controllerGrip = renderer.xr.getControllerGrip( 0 );
				controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
				scene.add( controllerGrip );

        var controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );
        
        // call animation/rendering loop
        animate();
        
      };

      function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

      function bob(object, x_direction, y_direction, z_direction) {

				object.position.x += 0.025 * Math.random() * x_direction;
        object.position.y += 0.025 * Math.random() * y_direction;
        object.position.z += 0.025 * Math.random() * z_direction;

			}

      function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 500 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

      function animate() {

        const delta = clock.getDelta();

        if (controller) {
          raycaster.setFromXRController( controller );
        } else {
          var pixel_coords = new THREE.Vector2( oldX, oldY );

          var vp_coords = new THREE.Vector2( 
                      ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                      -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

          var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

          raycaster.setFromCamera(vp_coords_near, camera);
        }
        

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 && intersects[0].object != ground && intersects[0].object != sky) {
          intersects[0].object.visible = false;
				}

				if ( red_mixer ) {

					red_mixer.update( delta );

				};

        if ( orange_mixer ) {

					orange_mixer.update( delta );

				};

        if ( yellow_mixer ) {

					yellow_mixer.update( delta );

				};

        if ( green_mixer ) {

					green_mixer.update( delta );

				};
        
        if ( blue_mixer ) {

					blue_mixer.update( delta );

				};

        if ( purple_mixer ) {

					purple_mixer.update( delta );

				};

        for (var i = 0; i < scene.children.length; i++){
          if (Math.random() < 0.001) {
            xdir[i] = -xdir[i];
          };
          if (Math.random() < 0.001) {
            ydir[i] = -ydir[i];
          };
          if (Math.random() < 0.001) {
            zdir[i] = -zdir[i];
          };

          if (Math.abs(scene.children[i].x) > 500) {
            xdir[i] = scene.children[i].x > 0 ? -1 : 1;
          };
          if (scene.children[i].y < 0) {
            ydir[i] = 1;
          };
          if (Math.abs(scene.children[i].z) > 500) {
            zdir[i] = scene.children[i].z > 0 ? -1 : 1;
          };

          if (scene.children[i] != ground && scene.children[i] != sky && Math.random() > 0.7){
            bob(scene.children[i], xdir[i], ydir[i], zdir[i]);
          };
        };

        renderer.setAnimationLoop(animate);

        // ... update renderer + controls
        controls.update();

        renderer.render(scene, camera);

      };
    </script>
  </head>
  <body></body>
</html>