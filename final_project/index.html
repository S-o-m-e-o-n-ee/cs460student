<html>
  <head>
    <style>
      html, body { 
        background-color:#000000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

    <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; 

    import {VRButton} from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js'; 

    var scene, camera, renderer, controls, controller, controller2, raycaster, bubbles, light;

    var baseReferenceSpace;

    var clock, sky, ground, isSelecting;

    var xdir, ydir, zdir;

    const bubbleUniforms = {
      uTime: { value: 0 },
      uDistort: { value: 0.5 }
    };

    const bubbleMaterial = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(0.9, 0.9, 1.0),
      transmission: 1.05,
      thickness: -0.5,
      roughness: 0,
      iridescence: 1,
      iridescenceIOR: 1,
      iridescenceThicknessRange: [0, 1200],
      clearcoat: 1,
      clearcoatRoughness: 0,
      envMapIntensity: 1.5,
      transparent: true,
      opacity: 0.5
    });

    // Inject vertex distortion
    bubbleMaterial.onBeforeCompile = (shader) => {
      shader.uniforms.uTime = bubbleUniforms.uTime;
      shader.uniforms.uDistort = bubbleUniforms.uDistort;

      shader.vertexShader = shader.vertexShader
        .replace(
          '#include <common>',
          `
          #include <common>

          uniform float uTime;
          uniform float uDistort;

          // Simple 3D noise
          float noise(vec3 p) {
            return sin(p.x) * sin(p.y) * sin(p.z);
          }
          `
        )
        .replace(
          '#include <begin_vertex>',
          `
          vec3 transformed = position;
          float n = noise(normal + uTime * 0.5);
          transformed += normal * n * uDistort;
          `
        );
    };

      window.onload = function() {
        
        window.THREE = THREE;

        //
        // THREE.js code goes here!
        //

        // Create the scene
        scene = new THREE.Scene();

        // Set up the camera
        var fov = 75;
        var ratio = window.innerWidth / window.innerHeight;
        var zNear = 1;
        var zFar = 1000;

        camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
        camera.position.set(0, 0, 1);

        // Create the renderer and add the canvas
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.xr.enabled = true; 
        renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );

        document.body.appendChild(renderer.domElement);

        document.body.appendChild(VRButton.createButton(renderer));

        // Setup lights
        var ambientLight = new THREE.AmbientLight();
        scene.add(ambientLight);

        light = new THREE.DirectionalLight(0xffffff, 3.0);
        light.position.set(10, 100, 10);
        scene.add(light);



        // Background

        var geometry = new THREE.SphereGeometry( 500, 60, 40 );
        
        var texture = new THREE.TextureLoader().load( 'sky.jpg' );
        var material = new THREE.MeshBasicMaterial( { map: texture,
                                                    side: THREE.BackSide } );
        sky = new THREE.Mesh( geometry, material );
        scene.add( sky );


        // // Configure cube
        // var geometry = new THREE.BoxGeometry(20, 20, 20);
        // var material = new THREE.MeshStandardMaterial({color:0xffffff, wireframe:false});

        // var cube = new THREE.Mesh(geometry, material);
        // // scene.add(cube);
        
        // Ground
        geometry = new THREE.PlaneGeometry( 10000, 10000 );
        material = new THREE.MeshStandardMaterial( {
          color: new THREE.Color(0.7, 0.7, 1.0), roughness: 0, metalness: 0.25
        });

        geometry.rotateX( 3 * Math.PI / 2 );

        ground = new THREE.Mesh( geometry, material );

        ground.translateY(-10);

        scene.add( ground );


        // Bubbles

        bubbles = new THREE.Group();
        scene.add(bubbles);

        var radius, x, y, z;

        for (var i = 0; i < 4000; i++) {
          radius = Math.random() * 5; 
          
          x = (Math.random() * 1000) - 500;
          y = (Math.random() * 30) - 5;
          z = (Math.random() * 1000) - 500;

          geometry = new THREE.SphereGeometry( radius, 32, 16 );
          material = bubbleMaterial;

          var sphere = new THREE.Mesh(geometry, material);  
          
          sphere.position.set(x, y, z);

          bubbles.add(sphere);
        };
    
        // Setup interaction
        controls = new OrbitControls(camera, renderer.domElement);

        renderer.xr.addEventListener('sessionstart', () => {
          controls.enabled = false;
        });

        renderer.xr.addEventListener('sessionend', () => {
          controls.enabled = true;
        });

        raycaster = new THREE.Raycaster();

        clock = new THREE.Clock();

        window.addEventListener( 'resize', onWindowResize );

        renderer.domElement.onmousedown = function( e ){
          
            var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

            var vp_coords = new THREE.Vector2( 
                        ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                        -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

            var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

            raycaster.setFromCamera(vp_coords_near, camera);

            var intersects = raycaster.intersectObjects(bubbles.children);

            if ( intersects.length > 0 ) {
              intersects[0].object.visible = false;
              intersects[0].object.removeFromParent();
            };

            // update cube position
            // cube.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);

          };


          renderer.domElement.onmousemove = function( e ){
          
            var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

            var vp_coords = new THREE.Vector2( 
                        ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                        -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

            var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

            raycaster.setFromCamera(vp_coords_near, camera);

            var intersects = raycaster.intersectObjects(bubbles.children);

            if ( intersects.length > 0 ) {
              windPush(intersects[0]);
            };

            // update cube position
            // cube.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);

            
          };

        xdir = [];
        ydir = [];
        zdir = [];

        for (var i = 0; i < bubbles.children.length; i++){
          xdir.push(1);
          ydir.push(1);
          zdir.push(1);
        };

        controller = renderer.xr.getController( 0 );
        controller.addEventListener( 'selectstart', function () {
					controller.userData.isSelecting = true;

          raycaster.setFromXRController( controller );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
            intersects[0].object.visible = false;
            intersects[0].object.removeFromParent();
          }
        } );
				controller.addEventListener( 'selectend', function () {
					controller.userData.isSelecting = false;
        } );
        controller.addEventListener( 'connected', function ( event ) {

					const targetRayMode = event.data.targetRayMode;

					if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

						controller.add( buildController( event.data ) );

					}

				} );
				controller.addEventListener( 'disconnected', function () {

					controller.remove( controller.children[ 0 ] );

				} );
        scene.add(controller);


        controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', function () {
					controller2.userData.isSelecting = true;

          raycaster.setFromXRController( controller2 );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
            intersects[0].object.visible = false;
            intersects[0].object.removeFromParent();
          }
        } );
				controller2.addEventListener( 'selectend', function () {
					controller2.userData.isSelecting = false;
        } );
        controller2.addEventListener( 'connected', function ( event ) {

					const targetRayMode = event.data.targetRayMode;

					if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

						controller2.add( buildController( event.data ) );

					}

				} );
				controller2.addEventListener( 'disconnected', function () {

					controller2.remove( controller2.children[ 0 ] );

				} );
        scene.add(controller2);
        
        // call animation/rendering loop
        renderer.setAnimationLoop(animate);
        
      };

      function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

      function bob(object, x_direction, y_direction, z_direction) {

				object.position.x += 0.025 * Math.random() * x_direction;
        object.position.y += 0.025 * Math.random() * y_direction;
        object.position.z += 0.025 * Math.random() * z_direction;

			}

      function windPush(from_this_intersection) {

        var n = from_this_intersection.face.normal.clone();

        if (n.x < 0) {
          from_this_intersection.object.position.x += 0.30;
        } else {
          from_this_intersection.object.position.x -= 0.30;
        };

        if (n.y > 0) {
          from_this_intersection.object.position.y -= 0.30;
        } else {
          from_this_intersection.object.position.y += 0.30;
        };

        if (n.z > 0) {
          from_this_intersection.object.position.z -= 0.30;
        } else {
          from_this_intersection.object.position.z += 0.30;
        };
      }

      function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 500 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

      function animate() {

        const delta = clock.getDelta();

        var time = clock.getElapsedTime();

        bubbleUniforms.uTime.value = time;

        if (controller) {
          raycaster.setFromXRController( controller );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
             windPush(intersects[0]);
          };
        } 

        if (controller2) {
          raycaster.setFromXRController( controller2 );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
             windPush(intersects[0]);
          };
        }

				if (light) {
          light.color.setHSL(((time/100) % 1), 0.7, 0.9);
        }

        for (var i = 0; i < bubbles.children.length; i++){
          if (Math.random() < 0.001) {
            xdir[i] = -xdir[i];
          };
          if (Math.random() < 0.001) {
            ydir[i] = -ydir[i];
          };
          if (Math.random() < 0.001) {
            zdir[i] = -zdir[i];
          };

          if (Math.abs(bubbles.children[i].position.x) > 500) {
            xdir[i] = bubbles.children[i].position.x > 0 ? -1 : 1;
          };
          if (bubbles.children[i].position.y < -5) {
            ydir[i] = 1;
          };
          if (Math.abs(bubbles.children[i].position.z) > 500) {
            zdir[i] = bubbles.children[i].position.z > 0 ? -1 : 1;
          };

          if (Math.random() > 0.7){
            bob(bubbles.children[i], xdir[i], ydir[i], zdir[i]);
          };
        };

        // ... update renderer + controls
        controls.update();

        renderer.render(scene, camera);

      };
    </script>
  </head>
  <body></body>
</html>