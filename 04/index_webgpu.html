<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>WebGPU Fishies!</title>
    <style>
      html, body { 
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
        background: url('https://cs460.org/assignments/04/bg.jpg');
        background-size: cover;
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="wgsl">
    struct VertexInput {
        @location(0) position: vec3<f32>,
        @location(1) transform_row0: vec4<f32>,
        @location(2) transform_row1: vec4<f32>,
        @location(3) transform_row2: vec4<f32>,
        @location(4) transform_row3: vec4<f32>,
        @location(5) color: vec4<f32>, // Color for the instance
    };

    struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) color: vec4<f32>, // Pass color to fragment shader
    };

    @vertex
    fn main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;
        let transform = mat4x4<f32>(
            input.transform_row0,
            input.transform_row1,
            input.transform_row2,
            input.transform_row3
        );
        output.position = transform * vec4(input.position, 1.0); // Add offset
        output.color = input.color; // Pass color to fragment shader
        return output;
    }
  </script>
  
  <script id="fragmentshader" type="wgsl">
    @fragment
    fn main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {
        return color; // Use the color passed from the vertex shader
    }
  </script>
  
  <script>
    var canvas, adapter, device, context, pipeline;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, fishies;

    window.onload = async function() {
      //************************************************************//
      // INITIALIZE WEBGL
      //************************************************************//
      canvas = document.getElementById('c');
      adapter = await navigator.gpu.requestAdapter();
      device = await adapter.requestDevice();
      context = canvas.getContext('webgpu');

      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: format,
        alphaMode: 'opaque'
      });

      //************************************************************//
      // SHADERS
      //************************************************************//
      v_shader = device.createShaderModule({
        code: document.getElementById('vertexshader').innerText
      });
      f_shader = device.createShaderModule({
        code: document.getElementById('fragmentshader').innerText
      });
      
      // create multiple fishies
      fishies = [];
      fishies.push(createFish(
        new Float32Array([0,0,0]), 
        new Float32Array([1.,0.,0.,1.]), 
        1, -1
      ));

      for (var i = 0; i < 100; i++) {
        random_offset = [Math.random()-Math.random(), Math.random()-Math.random(), 0];
        random_color = [Math.random(), Math.random(), Math.random(), Math.random()];
        random_scale = Math.random() * 0.3;
        fishies.push(createFish(
          new Float32Array(random_offset), 
          new Float32Array(random_color), 
          random_scale, 
          1
        ));
      }

      // Adds functions when certain keys are pressed
      window.onkeypress = function(e) {
        if (e.key == 'w') { fishies[0][4][1] += 0.05; }
        if (e.key == 'a') { fishies[0][4][0] -= 0.05; }
        if (e.key == 's') { fishies[0][4][1] -= 0.05; }
        if (e.key == 'd') { fishies[0][4][0] += 0.05; }
      };

      //************************************************************//
      // SETUP RENDERING PIPELINE
      //************************************************************//
      pipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: v_shader,
          buffers: [
            {
              arrayStride: 3*4, // vec3<f32>
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x3' }
              ],
              stepMode: 'vertex'
            },
            {
              arrayStride: 4 * 4 * 4, 
              attributes: [
                { shaderLocation: 1, offset: 0,  format: 'float32x4' },
                { shaderLocation: 2, offset: 16, format: 'float32x4' },
                { shaderLocation: 3, offset: 32, format: 'float32x4' },
                { shaderLocation: 4, offset: 48, format: 'float32x4' }
              ],
              stepMode: 'instance'
            },
            {
              arrayStride: 4 * 4, // Color size
              attributes: [
                { shaderLocation: 5, offset: 0, format: 'float32x4' }
              ],
              stepMode: 'instance'
            }
          ]
        },
        fragment: {
          module: f_shader,
          targets: [{
            format: format,
            blend: {
              color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
              alpha: { srcFactor: 'one', dstFactor: 'zero', operation: 'add' }
            }
          }]
        },
        primitive: {
          topology: 'triangle-list'
        }
      });

      animate();
    };

    function createFish(offset, color, scale, direction) {
      //************************************************************//
      // CREATE GEOMETRY
      //************************************************************//
      var vertices = new Float32Array([
        0.0,  0.0, 0.0, 
        0.5,  0.0, 0.0, 
       -1.0,  0.0, 0.0, 
        0.0,  0.5, 0.0, 
        0.0, -0.5, 0.0, 
       -1.25,-0.25, 0.0,
       -1.25, 0.25, 0.0,
       -0.9, 0.0,  0.0, 
        0.15, (direction == -1) ? -0.15 : 0.15, 0.0, 
        0.1, (direction == -1) ? -0.15 : 0.15, 0.0, 
        0.15, (direction == -1) ? -0.1 : 0.1, 0.0, 
        0.1, (direction == -1) ? -0.1 : 0.1, 0.0
      ]);                               

      var v_buffer = device.createBuffer({
        size: vertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(v_buffer.getMappedRange()).set(vertices);
      v_buffer.unmap();

      var indices = new Uint16Array([1, 2, 3, 1, 2, 4, 7, 5, 6, 8, 9, 10, 9, 10, 11]);

      var i_buffer = device.createBuffer({
        size: Math.ceil(indices.byteLength / 4) * 4, 
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(i_buffer.getMappedRange()).set(indices);
      i_buffer.unmap();

      // update position
      if (fishies.length != 0) {
        offset[0] += 0.01;
        offset[1] += 0.1*Math.random();
        offset[1] -= 0.1*Math.random();
      }

      var side_to_side_teleport = 1;
      var side_to_side_fix = 0;
      if (offset[0] > 1) { side_to_side_teleport = -1; side_to_side_fix = -0.1; }
      else if (offset[0] < -1) { side_to_side_teleport = -1; side_to_side_fix = 0.1; }
      offset[0] = side_to_side_teleport * (offset[0] + side_to_side_fix);

      var up_down_teleport = 1;
      var up_down_fix = 0;
      if (offset[1] >= 1) { up_down_teleport = -1; up_down_fix = -0.1; }
      else if (offset[1] <= -1) { up_down_teleport = -1; up_down_fix = 0.1; }
      offset[1] = up_down_teleport * (offset[1] + up_down_fix);

      var theta = Math.random() * 10 * Math.PI / 180; // convert 0..10 degrees to radians
      if (fishies.length == 0) { theta = 0; }

      var transform = new Float32Array([
        direction * scale * Math.cos(theta), Math.sin(theta), 0, 0,
        -Math.sin(theta), direction * scale * Math.cos(theta), 0, 0,
        0, 0, direction * scale * 1, 0,
        offset[0], offset[1], offset[2], 1
      ]);

      var transform_buffer = device.createBuffer({
        size: transform.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      });

      var color_buffer = device.createBuffer({
        size: color.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      });

      device.queue.writeBuffer(transform_buffer, 0, transform);
      device.queue.writeBuffer(color_buffer, 0, color);

      return [v_buffer, i_buffer, transform_buffer, color_buffer, offset, scale, direction, transform];
    };

    function animate() {
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();

      const renderPassDescriptor = {
        colorAttachments: [{
          view: textureView,
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store'
        }]
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);

      for (var r = 0; r < fishies.length; r++) {
        var current_buffers = fishies[r];
        var current_v_buffer = current_buffers[0];
        var current_i_buffer = current_buffers[1];
        var current_transform_buffer = current_buffers[2];
        var current_color_buffer = current_buffers[3];            
        var current_offset = current_buffers[4];
        var current_scale = current_buffers[5];
        var current_direction = current_buffers[6];
        var current_transform = current_buffers[7];

        //************************************************************//
        // CONNECT SHADER WITH GEOMETRY
        //************************************************************//
        t = performance.now() * 0.001;
        a = 0.6 + 0.4 * Math.sin(t * 2.0); // 0.2..1.0
        current_color = new Float32Array([
          0.3 + 0.2*Math.sin(t + 0.0),
          0.6 + 0.2*Math.sin(t + 2.0),
          0.9 + 0.1*Math.sin(t + 4.0),
          a
        ]);

        if (r == 0) {
          current_color = new Float32Array([1,0,0,0.9]);
        }

        var theta = Math.random() * 10 * Math.PI / 180;
        if (fishies.length == 0) { theta = 0; }

        current_transform.set([
          current_direction * current_scale * Math.cos(theta), Math.sin(theta), 0, 0,
          -Math.sin(theta), current_direction * current_scale * Math.cos(theta), 0, 0,
          0, 0, current_direction * current_scale * 1, 0,
          current_offset[0], current_offset[1], current_offset[2], 1
        ]);

        device.queue.writeBuffer(current_transform_buffer, 0, current_transform);
        device.queue.writeBuffer(current_color_buffer, 0, current_color);

        passEncoder.setVertexBuffer(0, current_v_buffer);
        passEncoder.setVertexBuffer(1, current_transform_buffer);
        passEncoder.setVertexBuffer(2, current_color_buffer);
        passEncoder.setIndexBuffer(current_i_buffer, 'uint16'); 
        passEncoder.drawIndexed(15);
            

            
      };

      //device.queue.writeBuffer(i_buffer, 0, instanceOffsets);

      passEncoder.end();
      device.queue.submit([commandEncoder.finish()]);
      requestAnimationFrame(animate);

    };

  </script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>
