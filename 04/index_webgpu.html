<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>WebGPU Fishies!</title>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
        background: url('https://cs460.org/assignments/04/bg.jpg');
        background-size: cover;
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="wgsl">
    struct VertexInput {
        @location(0) position: vec3<f32>,
        @location(1) transform: mat4<f32>,
        @location(2) color: vec4<f32>, // Color for the instance
        @location(3) pointsize: float,
    };

    struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) color: vec4<f32>, // Pass color to fragment shader
        @location(1) pointsize: float,
    };

    fn main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;
        output.position = input.transform * vec4(input.position, 1.0); // Add offset
        output.color = input.color; // Pass color to fragment shader
        output.pointsize = input.pointsize;
        return output;
    }
  </script>
  
  <script id="fragmentshader" type="wgsl">
    @fragment
    fn main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {
        return color; // Use the color passed from the vertex shader
    }
  </script>
  
  <script>

    var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;

    var score;
    score = 0;

    window.onload = async function() {

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
      const canvas = document.getElementById('c');
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      const context = canvas.getContext('webgpu');

      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: format,
        alphaMode: 'opaque'
      });


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = device.createShaderModule({
        code: document.getElementById('vertexshader').innerText
      });
      f_shader = device.createShaderModule({
        code: document.getElementById('fragmentshader').innerText
      });
      
      // create multiple fishies
      fishies = [];

      fishies.push(createFish(new Float32Array([0,0,0]), new Float32Array([1.,0.,0.,1.]), 1, -1));

      for (var i = 0; i < 100; i++) {
        random_offset = [Math.random()-Math.random(), Math.random()-Math.random(), 0];
        
        random_color = [Math.random(),Math.random(),Math.random(),Math.random()];

        random_scale = Math.random()*0.3;

        fishies.push(createFish(new Float32Array(random_offset), new Float32Array(random_color), random_scale, 1));
      }

        // Adds functions when certain keys are pressed
        window.onkeypress = function(e) {
            if (e.key == 'w') {
                fishies[0][3][1] += 0.05;
            };

            if (e.key == 'a') {
                fishies[0][3][0] -= 0.05;
            };

            if (e.key == 's') {
                fishies[0][3][1] -= 0.05;
            };

            if (e.key == 'd') {
                fishies[0][3][0] += 0.05;
            };
        };

      //************************************************************//
      //
      // SETUP RENDERING PIPELINE
      //
      const pipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: v_shader,
          buffers: [
            {
              arrayStride: 3 * 4, // Vertex size
              attributes: [{
                shaderLocation: 0,
                offset: 0,
                format: 'float32x3'
              }]
            },
            {
              arrayStride: 3 * 4, // Instance size
              attributes: [{
                shaderLocation: 1,
                offset: 0,
                format: 'float32x3'
              }],
              stepMode: 'instance' // Instance data
            },
            {
              arrayStride: 4 * 4, // Color size
              attributes: [{
                shaderLocation: 2,
                offset: 0,
                format: 'float32x4'
              }],
              stepMode: 'instance' // Color data for each instance
            }
          ]
        },
        fragment: {
          module: f_shader,
          targets: [{
            format: format
          }]
        },
        primitive: {
          topology: 'triangle-list'
        }
      });

      animate();

    };


    function createFish(offset, color, scale, direction) {


      //************************************************************//
      //
      // CREATE GEOMETRY
      //
      var vertices = new Float32Array([
                                        0.0,  0.0, 0.0, // 0: 
                                        0.5,  0.0, 0.0, // 1: V0, V3
                                       -1.0,  0.0, 0.0, // 2: V1, V4, 
                                        0.0,  0.5, 0.0, // 3: V2
                                        0.0, -0.5, 0.0, // 4: V5
                                       -1.25,-0.25, 0.0,// 5: V7
                                       -1.25, 0.25, 0.0,// 6: V8
                                       -0.9, 0.0,  0.0 // 7: V6
                                      ]);                               
        
      // now use indices
      var indices = new Uint8Array([ 1, 2, 3, 1, 2, 4, 7, 5, 6 ]); // 9 bytes

      var v_buffer = device.createBuffer({
        size: vertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(v_buffer.getMappedRange()).set(vertices);
      v_buffer.unmap();


      var i_buffer = device.createBuffer({
        size: indices.byteLength,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(i_buffer.getMappedRange()).set(indices);
      i_buffer.unmap();

      var eye_vertex = new Float32Array([0.125, 0.125, 0.0]);

      if (direction == -1) {
        eye_vertex = new Float32Array([0.125, -0.125, 0.0]);
      }

      var eye_v_buffer = device.createBuffer({
        size: eye_vertex.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(eye_v_buffer.getMappedRange()).set(eye_vertex);
      eye_v_buffer.unmap();

      return [v_buffer, i_buffer, eye_v_buffer, offset, color, scale, direction];

    };

    var step_x = .01;
    var step_y = .01;
    var direction = -1;

    function animate() {

        requestAnimationFrame(animate);

        gl.clearColor(0., 0., 0., 0.)
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        gl.disable(gl.DEPTH_TEST);



        for(var r = 0; r < fishies.length; r++) {

            // current_buffers is a list of [v_buffer, i_buffer]-pairs
            var current_buffers = fishies[r];
            var current_v_buffer = current_buffers[0];
            var current_i_buffer = current_buffers[1];
            var current_eye_v_buffer = current_buffers[2];
            var current_offset = current_buffers[3];
            var current_color = current_buffers[4];
            var current_scale = current_buffers[5];
            var current_direction = current_buffers[6];

            // Let the big fish eat little fish
            eaten = r!=0 && current_offset[0] >= fishies[0][3][0] - 0.25 && current_offset[0] <= fishies[0][3][0] + 0.25 && current_offset[1] >= fishies[0][3][1] - 0.25 && current_offset[1] <= fishies[0][3][1] + 0.25;
            if (eaten) {
                score++;
                document.getElementById("score").innerHTML = score;
                console.log(score);
                fishies.splice(r, 1);
                continue;
            };

            
            // update possition

            if (r != 0) {
                current_offset[0] += 0.01;
                current_offset[1] += 0.1*Math.random();
                current_offset[1] -= 0.1*Math.random();
            };
                var side_to_side_teleport = 1;
                var side_to_side_fix = 0;
                if (current_offset[0] > 1) {
                    side_to_side_teleport = -1;
                    side_to_side_fix = -0.1;
                } else if (current_offset[0] < -1) {
                    side_to_side_teleport = -1;
                    side_to_side_fix = 0.1;
                };
                
                current_offset[0] = side_to_side_teleport * (current_offset[0] + side_to_side_fix);

                var up_down_teleport = 1;
                var up_down_fix = 0;

                // bumped into top or bottom edge of screen
                if ( current_offset[1] >= 1) {
                    up_down_teleport = -1;
                    up_down_fix = -0.1;
                } else if (current_offset[1] <= -1) {
                    up_down_teleport = -1;
                    up_down_fix = 0.1;
                };
                current_offset[1] = up_down_teleport * (current_offset[1] + up_down_fix);

            



            //************************************************************//
            //
            // CONNECT SHADER WITH GEOMETRY
            //
            
            gl.bindBuffer(gl.ARRAY_BUFFER, current_v_buffer);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, current_i_buffer);

            // find the attribute in the shader source
            var a_position = gl.getAttribLocation(shaderprogram, 'a_position');

            gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray (a_position);

            // find the uniform in the shader source

            var theta = Math.random()*10 * Math.PI/180; // convert 0..10 degrees to radians

            if (r == 0) {
                theta = 0;
            }

            var transform = [current_direction * current_scale * Math.cos(theta), Math.sin(theta), 0, 0,
                            -Math.sin(theta), current_direction * current_scale * Math.cos(theta), 0, 0,
                            0, 0, current_direction * current_scale * 1, 0,
                            current_offset[0], current_offset[1], current_offset[2], 1];

            var u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');

            gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform))

            t = performance.now() * 0.001;
            a = 0.6 + 0.4 * Math.sin(t * 2.0); // 0.2..1.0
            current_color = new Float32Array([
                0.3 + 0.2*Math.sin(t + 0.0),
                0.6 + 0.2*Math.sin(t + 2.0),
                0.9 + 0.1*Math.sin(t + 4.0),
                a
            ]);

            if (r == 0) {
                // the large fish aka. first object should still be red!
                current_color = [1,0,0,0.9];
            }

            gl.uniform4fv( u_color, current_color );
            
            var u_color = gl.getUniformLocation(shaderprogram, 'u_color');
            
            gl.uniform4fv(u_color, current_color);

            //************************************************************//
            //
            // DRAW!
            //


            gl.drawElements(gl.TRIANGLES, 9, gl.UNSIGNED_BYTE, 0);



            gl.uniform4fv(u_color, new Float32Array([0, 0, 0, .5]));

            u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');

            gl.uniform1fv(u_pointsize, new Float32Array([current_scale*20.]));

            gl.enableVertexAttribArray ( a_position );
        
            gl.bindBuffer( gl.ARRAY_BUFFER, current_eye_v_buffer);
            
            gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_position);

            gl.drawArrays( gl.POINTS, 0, 1);

        }


    };

  </script>
  <body>
    Eat the other fish! Move with the WASD keys. Score: <span id="score"></span>
    <canvas id="c"></canvas>
  </body>
</html>
